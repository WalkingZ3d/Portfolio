import { Project } from "./Project";

export const PROJECTS: Project[] = [
    {
        id: 0,
        title: 'Calorie Tracker',
        link: 'calorie-tracker',
        url: 'https://dan-calorie-tracker.herokuapp.com/',
        GitHub: 'https://github.com/WalkingZ3d/CalorieTracker2',
        summary: 'A fullstack application for tracking calories. This app uses an Express.js backend, NoSql database (with MongoDB) and serves EJS files for the frontend views whilst employing an MVC model for separation of concerns and CRUD functionality.',
        description: 'A fullstack application for tracking calories. This app uses an Express.js backend, NoSql database (with MongoDB) and serves EJS files for the frontend views whilst employing an MVC model for separation of concerns and CRUD functionality.',
        picture: '../../../assets/images/calorieTracker/calorieTracker.png',
        stamp: '../../../assets/images/stamps/personal-pink-clear.png',
        framework: '../../../assets/images/frameworkIcons/node-logo.png',
        screenshot: [['Index Page for the calorie tracker, found at the root "/" endpoint. The user is invited to click on the link to begin to track calories. If they are not logged in, this will redirect them to the login form. If they are, they will be navigated to the "Days" page.', '../../../assets/images/calorieTracker/calorieTracker.png'], ['The login form found at "/login". The user must enter a valid existing username and correct password to log in, failure to do so will result in not logging in. If a user does not have an account they are prompted to register via the signup form.', '../../../assets/images/calorieTracker/screenshot-2.png'],  ['The signup form found at "/signup". Here the user must enter a valid email (for which both server side and client side validation ensures), a unique username and a password at least 5 characters long. If this is done, a new user will be added to the database once password has been encrypted.', '../../../assets/images/calorieTracker/screenshot-3.png'], ['A form displaying the custom error handling to users, invalid password (too short) on signup in this example.', '../../../assets/images/calorieTracker/screenshot-4.png'],['Once logged in, a user is able to see a record of the days they have been logging at "/days". 7 days can be created per page, each of which must be unique. The necessity for user login is the connection between user and stored data. More than one user is likely to have a Day 1 and so each day object is linked by id to each user. This page is populated by a GET request with the user id from the JWT cookie to fetch the days array in the user object.', '../../../assets/images/calorieTracker/screenshot-5.png'], ['Server side error handling when trying to make a day that already exists for that user.', '../../../assets/images/calorieTracker/screenshot-6.png'],
        ['A new page for each new week. The "Previous" and "Next" buttons allow pagination control. Each day is a link to the entry page for that day.', '../../../assets/images/calorieTracker/screenshot-7.png'],
        ['The dayId (link between user and day) is passed from the day page as a url parameter. This is the entry for a day before any food is added found at the endpoint "/entry/:dayId. To add a food to this day, a user must press the "Add A Food!" button. ', '../../../assets/images/calorieTracker/screenshot-8.png'], ['The form used to add food is found at "/food". In order to add food to the right day, the local session is populated with the dayId on the previous page and then sent to the server with the added food object. This ensures the food is added to the correct day.', '../../../assets/images/calorieTracker/screenshot-9.png'], ['Once a food has been added, it will appear in the entry page. The total calorie amount can be seen above the top right of the table, where the calorie numbers are dynamically updated to the total for each new food.', '../../../assets/images/calorieTracker/screenshot-10.png'], ['The entry after a user has clicked the delete icon to remove a food object from this day. The food object is both deleted from the array of foods for this day, and the object is deleted from the database to avoid repeats. The calorie total is also updated automatically.', '../../../assets/images/calorieTracker/screenshot-11.png']],

        code: [['The sever instance and routes for the backend of the application. As this app is designed to scale with more functionality, the MVC model has been used to allow for a structured folder and file system which enables far easier addition of new code. The Middleware on line 68, causes all GET routes to check if a user is logged in before sending any resources. As seen below, some routes will "requireAuth", implementing required login state for certain areas of the application. Currently, the required routes are the "indexRoutes" for the home page, "authRoutes" to handle user login and "calorieRoutes" that handle requests from the front end in regards to the calorie tracking. Lines 75-77 show the catch-all used to allow the display of a custom 404 page if the user naviagates away from the avilable routes.', '../../../assets/images/calorieTracker/code-1.png'], ['Middleware for the authentication. When users are logged in, a cookie is saved with the corresponding JSON Web Token (JWT) which this middle ware uses in each function. "requireAuth" checks for a cookie and goes to the next process in the stack with line 24 if it is valid, however if it doesnt not exist or is invalid, the user is redirecetd to the login page. This is applied to every endpoint that needs to be hidden from a non-logged in user - such as the page that displays eaten food. "checkUser" sets the local variable of "user" to the username if found so it can be displayed on the page in the header, if a user is not logged in this function simply passes the process along the stack with the user as null.', '../../../assets/images/calorieTracker/code-2.png'], ['A basic example from the controller, this is the index controller method called on a GET request to "/" and simply returns the index page. The EJS template for frontend views allows variables to be easily passed from the backend to the frontend. In this example, the page title is set as "Home" and so the tab in the browser will read "Calorie Tracker | Home". ', '../../../assets/images/calorieTracker/code-3.png'], ['User authentication for this application requires the following routes, none of which include the "requireAuth" Middleware. The function for each route can be found within the controller for authentication.', '../../../assets/images/calorieTracker/code-4.png'], [ 'Both of the GET requests respond with the approriate form to either login or create a new account. The signup form sends a POST request to "/signup" to add a new user where the controller function first deconstructs the request body to acquire the email, username and password. With this information, the a new "User" is added to the database and the token is created with their JWT, lasting 3 days after which the user will have to login back in. Similarly, the login form sends a POST request to "/login" where the User Schema\'s static method "login" is called to authenticate if that user exists in the database with Bcrypt compare. If successful, the JWT cookie is created as before. In both cases, an unsuccessful login or signup will return a custom error handling object as seen below. To logout the cookie lifetime is set to 1 millisecond and so effectively is deleted.', '../../../assets/images/calorieTracker/code-5.png'], ['When a user tries to login with an account that doesnâ€™t exist or signup with an already taken username, the database queries will fail and return an error. To aid the user, the exact nature of the failure is added to an error object sent back to the frontend after a failed POST request, allowing the frontend to display the error clearly.', '../../../assets/images/calorieTracker/code-6.png'], ['The Schema for creating new user objects within the users document in the database. Each will have a required email, username and password with server side validations such as minimum length and email mongoose email validation. NoSQL was chosen for this project as it allows for easy nesting of objects within the database. This is seen here where each user is assigned a day property with the type of an array of "daySchema" objects.', '../../../assets/images/calorieTracker/code-7.png'], [ 'Mongoose allows for Schemas to have Hooks such as before and after saving a new object to the database. I have added a pre Hook to salt and hash passwords using the bcrypt library, which is an essential feature for security as it prevents user passwords being vunerable to data leaks or unauthorizied access as the .env file contains the JWT secret and is not uploaded to the GitHub thanks to .gitignore.', '../../../assets/images/calorieTracker/code-8.png'], ['The "Day" Schema the template for day objects to be added to each user. As such, each contains a "userId" which associates it with the logged in user. This is not unique as there is a One to Many relationship occuring, where each user may have many days of tracking but each day object can only be associated with a single user. "dayId" is unique so no 2 day objects can be added for each user and is created by appending the "userId" onto the current day number - e.g. for user 777, day 1 would have the "dayId" 1777. Similarly to users, each day can contain foods, which is added as an array of food objects. It is not a required field as when a new day is added, it will not yet contain any food objects. Whilst developing it was initally required, but as no new days could be created without already having food and since you cannot create a food object before a day, no new days would be added. The static method "findByDayId" was created to allow the calorie controller to return a day for a user given the "dayId" with the Mongoose method "findOne". Previously, I was trying to use "findById" but this is a built in Mongoose method that uses the auto generated "_id" and so was causing errors. Since each day has been linked to the user and contains the day number for a unique dayId, the correct day can easily be found and returned.', '../../../assets/images/calorieTracker/code-9.png'], ['For food, the "userDayId" field is populated with the "dayId" with the associated day with "-Number" appended. E.g. if user 777 added an apple to day 1, "userDayId" would be 1777-1. The name of each food added an calorie amount is acquired from an external database when the food is added via POST requests to "/calorie" in the backend to protect my API key located in the .env file.', '../../../assets/images/calorieTracker/code-10.png'], ['The header partial is applied to all pages and contains conditional rendering between lines 33 and 48. If a user exists as seen previously from the authentication Middleware, then display "Welcome username" and the logout button, else the login and signup buttons.', '../../../assets/images/calorieTracker/code-11.png'], ['An example of an EJS template. The partials included in each page are the header and footer components located in a separate folder/file, similar to React or Angular. This particular page is for the login form.', '../../../assets/images/calorieTracker/code-12.png'], ['The routes for the calorie part of the application. The GET requests that return pages require the authentication Middleware to prevent logged out users accessing the resources as everything is linked to users by Id.', '../../../assets/images/calorieTracker/code-13.png'], ['When a user goes to "/days", this code is ran in the browser. A GET request to "/daysList" will return the array of day objects associated with that user. These are then iterated over to populate the table of days seen on the page. Each day is given the href of "/entry/:dayId" so clicking on each day will take you to the entry for said day.', '../../../assets/images/calorieTracker/code-14.png'], ['The GET request to "/daysList" is handled by this method in the calorie controller. The JWT in the cookie from the authentication is used to query the database for the logged in user. This returns the days array to the front end for use as above.','../../../assets/images/calorieTracker/code-15.png'], ['To add a day, a user enters a number into the bar at the top of the page and presses "Add". This form has an event listener as seen here that fires a POST request to "/days" with the number entered as dayName, validated by the client only allowing positive integers to be entered. If this cannot be added to the database (due to a repeated day), the custom errors object is resolved and used to display to the user. ', '../../../assets/images/calorieTracker/code-16.png'], ['On the server side, the cookie is once again used to acquire the userId. A new object is then added to the database with a userId equal to the userId of the user logged in, and a dayId equal to the userId with the day number on appened to the beginning. The dayName is equal to "day" + number. Once sucessfully created, a new Promise is used push the new day object to the array of days on the user object - an example of where nested documents in NoSQL is helpful. These processes are surrounded by a try catch to ensure the errors can be handled if occuring.', '../../../assets/images/calorieTracker/code-17.png'], ['Since the URL parameters are added on the days page for navigation to this page, the entry page can be served with an EJS variable for the entry of foods for each day. Making a GET request to "/entry/:id" will fire this function in the controller. The URL parameters are deconstructed and passed into the static method of "findByDayId" on the Day Schema.', '../../../assets/images/calorieTracker/code-18.png'], ['EJS allows for very simple rendering when given expected input. The entry page uses the "foodList" property rendered by the GET request for this page, which contains the foods array of the day clicked on. The array is then iterated through to populate the table and calculate the total calories. The user can add more food with the "Add A Food!" button or delete a food from this day with the red delete icon.', '../../../assets/images/calorieTracker/code-20.png'], [' The user enters the food name and amount in the form (which is validated client side by only allowing text in the food name input and numbers in the grams input) and presses add, which fires this event listener. The first request is a POST to "/next" to calculate the id of the food to be added. The second request is to a POST to "/calorie". If successful, this will add a new food object to the database and append it to the food array for the day the user was adding to.', '../../../assets/images/calorieTracker/code-21.png'], ['This function in the calorie controller is used to calculate the id of the new food. To ensure a unique Id, the "userDayId" field is populated with the "dayID" of the day being added to + "-" and the counter of added foods so far. E.g. for user 777, on day 1, the first food added will have the id of 1777-1, the second will be "1777-2, day 2 will be "2777-1" and so on. This method will work out the highest -number and return one higher. So in the event a food of -3 is deleted but -4 is still there, the next food will still be -5.', '../../../assets/images/calorieTracker/code-22.png'], ['To acquire the data for the calorie amount, a 3rd party API is called (from the backend to hide my API key) with the query of food name and amount. Once the calorie number has been acquired, the correct day must be to get the correct Mongoose "_id" to query. This "_id_" along with the dayId + "-" + "id of food", food name and calorie amount are used to create a new Food object. If successful, a Promise (as this may take some time) is then used to find the day and push the new Food object to the array of foods for the correct day. The id system used in this application allows for each day and food to easily be identified and queried.', '../../../assets/images/calorieTracker/code-23.png'], ['Finally, if a user wants to delete a food from a paticular day, they can click on the red delete icon to do so from the entry page at "/entry/:id". Clicking this icon fires a DELETE requests to "/days" passing the dayId from the URL parameters and the id on the food (the "-num").', '../../../assets/images/calorieTracker/code-24.png'], ['The delete function in the calorie controller for this endpoint does 2 things. Firstly, the "-id" property ("userDayId") is used to delete the food from the database. Secondly, the day this food is associated with is found by the static "findByDayId" as before to get the "_id". A Promise is then again used to remove the food from the foods array for that day.', '../../../assets/images/calorieTracker/code-25.png']],
        // screenshot1: '../../../assets/images/calorieTracker/calorieTracker.png',
        // screenshot1Description: 'Index Page for the calorie tracker, found at the root "/" endpoint. The user is invited to click on the link to begin to track calories. If they are not logged in, this will redirect them to the login form. If they are, they will be navigated to the "Days" page.',
        // screenshot2: '../../../assets/images/calorieTracker/screenshot-2.png',
        // screenshot2Description: 'The login form found at "/login". The user must enter a valid existing username and correct password to log in, failure to do so will result in not logging in. If a user does not have an account they are prompted to register via the signup form.',
        // screenshot3: '../../../assets/images/calorieTracker/screenshot-3.png',
        // screenshot3Description: 'The signup form found at "/signup". Here the user must enter a valid email (for which both server side and client side validation ensures), a unique username and a password at least 5 characters long. If this is done, a new user will be added to the database once password has been encrypted.',
        // screenshot4: '../../../assets/images/calorieTracker/screenshot-4.png',
        // screenshot4Description: 'A form displaying the custom error handling to users, invalid password (too short) on signup in this example.',
        // screenshot5: '../../../assets/images/calorieTracker/screenshot-5.png',
        // screenshot5Description: 'Once logged in, a user is able to see a record of the days they have been logging at "/days". 7 days can be created per page, each of which must be unique. The necessity for user login is the connection between user and stored data. More than one user is likely to have a Day 1 and so each day object is linked by id to each user. This page is populated by a GET request with the user id from the JWT cookie to fetch the days array in the user object.',
        // screenshot6: '../../../assets/images/calorieTracker/screenshot-6.png',
        // screenshot6Description: 'Server side error handling when trying to make a day that already exists for that user.',
        // screenshot7: '../../../assets/images/calorieTracker/screenshot-7.png',
        // screenshot7Description: 'A new page for each new week. The "Previous" and "Next" buttons allow pagination control. Each day is a link to the entry page for that day.',
        // screenshot8: '../../../assets/images/calorieTracker/screenshot-8.png',
        // screenshot8Description: 'The dayId (link between user and day) is passed from the day page as a url parameter. This is the entry for a day before any food is added found at the endpoint "/entry/:dayId. To add a food to this day, a user must press the "Add A Food!" button. ',
        // screenshot9: '../../../assets/images/calorieTracker/screenshot-9.png',
        // screenshot9Description: 'The form used to add food is found at "/food". In order to add food to the right day, the local session is populated with the dayId on the previous page and then sent to the server with the added food object. This ensures the food is added to the correct day.',
        // screenshot10: '../../../assets/images/calorieTracker/screenshot-10.png',
        // screenshot10Description: 'Once a food has been added, it will appear in the entry page. The total calorie amount can be seen above the top right of the table, where the calorie numbers are dynamically updated to the total for each new food.',
        // screenshot11: '../../../assets/images/calorieTracker/screenshot-11.png',
        // screenshot11Description: 'The entry after a user has clicked the delete icon to remove a food object from this day. The food object is both deleted from the array of foods for this day, and the object is deleted from the database to avoid repeats. The calorie total is also updated automatically.',
        // code1: '../../../assets/images/calorieTracker/code-1.png',
        // code1Description: 'The sever instance and routes for the backend of the application. As this app is designed to scale with more functionality, the MVC model has been used to allow for a structured folder and file system which enables far easier addition of new code. The Middleware on line 68, causes all GET routes to check if a user is logged in before sending any resources. As seen below, some routes will "requireAuth", implementing required login state for certain areas of the application. Currently, the required routes are the "indexRoutes" for the home page, "authRoutes" to handle user login and "calorieRoutes" that handle requests from the front end in regards to the calorie tracking. Lines 75-77 show the catch-all used to allow the display of a custom 404 page if the user naviagates away from the avilable routes.',
        // code2: '../../../assets/images/calorieTracker/code-2.png',
        // code2Description: 'Middleware for the authentication. When users are logged in, a cookie is saved with the corresponding JSON Web Token (JWT) which this Middleware uses in each function. "requireAuth" checks for a cookie and goes to the next process in the stack with line 24 if it is valid, however if it doesnâ€™t not exist or is invalid, the user is redirected to the login page. This is applied to every endpoint that needs to be hidden from a non-logged in user - such as the page that displays eaten food. "checkUser" sets the local variable of "user" to the username if found so it can be displayed on the page in the header, if a user is not logged in this function simply passes the process along the stack with the user as null.',
        // code3:  '../../../assets/images/calorieTracker/code-3.png',
        // code3Description: 'A basic example from the controller, this is the index controller method called on a GET request to "/" and simply returns the index page. The EJS template for frontend views allows variables to be easily passed from the backend to the frontend. In this example, the page title is set as "Home" and so the tab in the browser will read "Calorie Tracker | Home". ',
        // code4:  '../../../assets/images/calorieTracker/code-4.png',
        // code4Description: 'User authentication for this application requires the following routes, none of which include the "requireAuth" Middleware. The function for each route can be found within the controller for authentication.',
        // code5:  '../../../assets/images/calorieTracker/code-5.png',
        // code5Description: 'Both of the GET requests respond with the approriate form to either login or create a new account. The signup form sends a POST request to "/signup" to add a new user where the controller function first deconstructs the request body to acquire the email, username and password. With this information, the a new "User" is added to the database and the token is created with their JWT, lasting 3 days after which the user will have to login back in. Similarly, the login form sends a POST request to "/login" where the User Schema\'s static method "login" is called to authenticate if that user exists in the database with Bcrypt compare. If successful, the JWT cookie is created as before. In both cases, an unsuccessful login or signup will return a custom error handling object as seen below. To logout the cookie lifetime is set to 1 millisecond and so effectively is deleted.',
        // code6:  '../../../assets/images/calorieTracker/code-6.png',
        // code6Description: 'When a user tries to login with an account that doesnâ€™t exist or signup with an already taken username, the database queries will fail and return an error. To aid the user, the exact nature of the failure is added to an error object sent back to the frontend after a failed POST request, allowing the frontend to display the error clearly.',
        // code7:  '../../../assets/images/calorieTracker/code-7.png',
        // code7Description: 'The Schema for creating new user objects within the users document in the database. Each will have a required email, username and password with server side validations such as minimum length and email mongoose email validation. NoSQL was chosen for this project as it allows for easy nesting of objects within the database. This is seen here where each user is assigned a day property with the type of an array of "daySchema" objects.',
        // code8:  '../../../assets/images/calorieTracker/code-8.png',
        // code8Description: 'Mongoose allows for Schemas to have Hooks such as before and after saving a new object to the database. I have added a pre Hook to salt and hash passwords using the bcrypt library, which is an essential feature for security as it prevents user passwords being vunerable to data leaks or unauthorizied access as the .env file contains the JWT secret and is not uploaded to the GitHub thanks to .gitignore.',
        // code9:  '../../../assets/images/calorieTracker/code-9.png',
        // code9Description: 'The "Day" Schema the template for day objects to be added to each user. As such, each contains a "userId" which associates it with the logged in user. This is not unique as there is a One to Many relationship occuring, where each user may have many days of tracking but each day object can only be associated with a single user. "dayId" is unique so no 2 day objects can be added for each user and is created by appending the "userId" onto the current day number - e.g. for user 777, day 1 would have the "dayId" 1777. Similarly to users, each day can contain foods, which is added as an array of food objects. It is not a required field as when a new day is added, it will not yet contain any food objects. Whilst developing it was initally required, but as no new days could be created without having already having food and since you cannot create a food object before a day, no new days would be added. The static method "findByDayId" was created to allow the calorie controller to return a day for a user given the "dayId" with the Mongoose method "findOne". Previously, I was trying to use "findById" but this is a built in Mongoose method that uses the auto generated "_id" and so was causing errors. Since each day has been linked to the user and contains the day number for a unique dayId, the correct day can easily be found and returned.',
        // code10: '../../../assets/images/calorieTracker/code-10.png',
        // code10Description: 'For food, the "userDayId" field is populated with the "dayId" with the associated day with "-Number" appended. E.g. if user 777 added an apple to day 1, "userDayId" would be 1777-1. The name of each food added an calorie amount is acquired from an external database when the food is added via POST requests to "/calorie" in the backend to protect my API key located in the .env file.',
        // code11: '../../../assets/images/calorieTracker/code-11.png',
        // code11Description: 'The header partial is applied to all pages and contains conditional rendering between lines 33 and 48. If a user exists as seen previously from the authentication Middleware, then display "Welcome username" and the logout button, else the login and signup buttons.',
        // code12: '../../../assets/images/calorieTracker/code-12.png',
        // code12Description: 'An example of an EJS template. The partials included in each page are the header and footer components located in a separate folder/file, similar to React or Angular. This particular page is for the login form.',
        // code13: '../../../assets/images/calorieTracker/code-13.png',
        // code13Description: 'The routes for the calorie part of the application. The GET requests require the authentication Middleware to prevent logged out users accessing the resources as everything is linked to users by Id.',
        // code14: '../../../assets/images/calorieTracker/code-14.png',
        // code14Description: 'When a user goes to "/days", this code is ran in the browser. A GET request to "/daysList" will return the array of day objects associated with that user. These are then iterated over to populate the table of days seen on the page. Each day is given the href of "/entry/:dayId" so clicking on each day will take you to the entry for said day.',
        // code15: '../../../assets/images/calorieTracker/code-15.png',
        // code15Description: 'The GET request to "/daysList" is handled by this method in the calorie controller. The JWT in the cookie from the authentication is used to query the database for the logged in user. This returns the days array to the front end for use as above.',
        // code16: '../../../assets/images/calorieTracker/code-16.png',
        // code16Description: 'To add a day, a user enters a number into the bar at the top of the page and presses "Add". This form has an event listener as seen here that fires a POST request to "/days" with the number entered as dayName, validated by the client only allowing positive integers to be entered. If this cannot be added to the database (due to a repeated day), the custom errors object is resolved and used to display to the user. ',
        // code17: '../../../assets/images/calorieTracker/code-17.png',
        // code17Description: 'On the server side, the cookie is once again used to acquire the userId. A new object is then added to the database with a userId equal to the userId of the user logged in, and a dayId equal to the userId with the day number on appened to the beginning. The dayName is equal to "day" + number. Once sucessfully created, a new Promise is used push the new day object to the array of days on the user object - an example of where nested documents in NoSQL is helpful. These processes are surrounded by a try catch to ensure the errors can be handled if occuring.',
        // code18: '../../../assets/images/calorieTracker/code-18.png',
        // code18Description: 'Since the URL parameters are added on the days page for navigation to this page, the entry page can be served with an EJS variable for the entry of foods for each day. Making a GET request to "/entry/:id" will fire this function in the controller. The URL parameters are deconstructed and passed into the static method of "findByDayId" on the Day Schema.' ,
        // code19: '../../../assets/images/calorieTracker/code-20.png',
        // code19Description: 'EJS allows for very simple rendering when given expected input. The entry page uses the "foodList" property rendered by the GET request for this page, which contains the foods array of the day clicked on. The array is then iterated through to populate the table and calculate the total calories. The user can add more food with the "Add A Food!" button or delete a food from this day with the red delete icon.' ,
        // code20: '../../../assets/images/calorieTracker/code-21.png',
        // code20Description: ' The user enters the food name and amount in the form (which is validated client side by only allowing text in the food name input and numbers in the grams input) and presses add, which fires this event listener. The first request is a POST to "/next" to calculate the id of the food to be added. The second request is to a POST to "/calorie". If successful, this will add a new food object to the database and append it to the food array for the day the user was adding to.' ,
        // code21: '../../../assets/images/calorieTracker/code-22.png',
        // code21Description: 'This function in the calorie controller is used to calculate the id of the new food. To ensure a unique Id, the "userDayId" field is populated with the "dayID" of the day being added to + "-" and the counter of added foods so far. E.g. for user 777, on day 1, the first food added will have the id of 1777-1, the second will be "1777-2, day 2 will be "2777-1" and so on. This method will work out the highest -number and return one higher. So in the event a food of -3 is deleted but -4 is still there, the next food will still be -5.' ,
        // code22: '../../../assets/images/calorieTracker/code-23.png',
        // code22Description: 'To acquire the data for the calorie amount, a 3rd party API is called (from the backend to hide my API key) with the query of food name and amount. Once the calorie number has been acquired, the correct day must be to get the correct Mongoose "_id" to query. This "_id_" along with the dayId + "-" + "id of food", food name and calorie amount are used to create a new Food object. If successful, a Promise (as this may take some time) is then used to find the day and push the new Food object to the array of foods for the correct day. The id system used in this application allows for each day and food to easily be identified and queried.' ,
        // code23: '../../../assets/images/calorieTracker/code-24.png',
        // code23Description: 'Finally, if a user wants to delete a food from a paticular day, they can click on the red delete icon to do so from the entry page at "/entry/:id". Clicking this icon fires a DELETE requests to "/days" passing the dayId from the URL parameters and the id on the food (the "-num").' ,
        // code24: '../../../assets/images/calorieTracker/code-25.png',
        // code24Description: 'The delete function in the calorie controller for this endpoint does 2 things. Firstly, the "-id" property ("userDayId") is used to delete the food from the database. Secondly, the day this food is associated with is found by the static "findByDayId" as before to get the "_id". A Promise is then again used to remove the food from the foods array for that day.' ,
    },
    {
        id: 1,
        title: 'Jigsaw Helper',
        GitHub: 'https://github.com/WalkingZ3d/JigsawHelper',
        summary: 'A Java application designed to help with jigsaw puzzles. The application is not web-based, but instead ran from the command line by the complier. This project was my dissertation for  my masters in Computer Science.',
        description: 'A Java application designed to help with jigsaw puzzles. The application is not web-based, but instead ran from the command line by the complier. This project was my dissertation for  my masters in Computer Science.',
        picture: '../../../assets/images/jigsawHelper/gui.png',
        stamp: '../../../assets/images/stamps/personal-pink-clear.png',
        framework: '../../../assets/images/frameworkIcons/java-logo.png',
        screenshot: [['The GUI for this Java application. The application interface is split into the 3 key areas: "The Finished Puzzle", "The Indivdiual Piece" and "The Location!!!!". In the top left, a user can upload an image of the puzzle (such as from the box), see more information and view the full size image. The same functionality occurs where the user is invited to upload the puzzle piece they need help locating. The location section is where the user will receive the answer to the location of the piece within the finished image, only once the 2 uploads have been carried out.', '../../../assets/images/jigsawHelper/gui.png'], ['After clicking on the "Find Piece" button, the program will draw a red box around the area most likely to contain the location of the piece. This is an example of a color search (conducted as there are no edges in the puzzle piece), which resulted in an excellent red box with the colour search because the colour in the piece was so vivid and unique to that area of the finished image.', '../../../assets/images/jigsawHelper/screenshot-2.png'], ['If the user clicks on the "Click Here To See All Possible Locations" button, a separate window will open. This window will contain the red box as before (indicating the most likely area) and the mean of the top 10 (if at least 10 possibilities) most likely locations in the blue box. The green box is the exact location and has been manually entered to test accuracy. With this example, the blue box was skewed to the right by the similar orange colours surrounding the light source of the sun in the finished image, pushing the mean away from the most accurate result. This test also only used 3 locations for the blue box mean result, as the colour search output only 3 suitable locations for the piece. ', '../../../assets/images/jigsawHelper/screenshot-3.png'], ['Another testing picture, The Zed image, has a bright center on the edge piece chosen which is surrounded by other sharp edges clearly influencing the greyscale pixel values as all 3 boxes feature it prominently. ', '../../../assets/images/jigsawHelper/screenshot-4.png'], ['The greyscale search for this image yielded more than 10 possibilites for location, and so the top 10 would have been used for the blue box.', '../../../assets/images/jigsawHelper/screenshot-5.png'], ['The accompanying image shows both the greyscale and color searches respectively. The most edge here is the sharp color change from red to black. The color search found a more accurate likely location. However, the greyscale search had a better mean result. This is likely due to the color edge being repeated 3 times across the image - as seen by the middle edge being highlighted as mean, whereas the grey scale could not determine between the left/right and right/left edge color shift. The conclusions drawn from this study were that the color array algorigthm was more accurate for determining location as it considered an extra dimension in the array. However, this caused a slower runtime - so the edge detection allowed the quicker greyscale search to be conducted where possible. The compression lossy suffered by images when uploaded to the application resulted in close but not exact matches. This uncertainty causes unreliability, so an optimisation that decreased the impact of compression lossy would be very beneficial.', '../../../assets/images/jigsawHelper/screenshot-6.png']],
        code: [['The method called by the completedFindButton() method in the GUI class CreateInterface to show the user where the piece fits, returning the LinkedHashMap "sortedMap" that contains all of the possible locations ranked by score (lower mean squared error is a better score) required to draw the rectangle onto the finished image. Initially, the sobelDetector() method is called to acquire the edge flag Boolean so the program knows whether to use the coloured 3d array or greyscale 2d array for the search. The threshold for the mean squared error is lower for the colour array as it is a more thorough search and therefore must have a stricter criteria to be considered a possible location. The "sortedMap" LinkedHashMap is where the possible locations for the piece are stored, ordered by their mean square error score, so the most likely piece is at the first part of the array.', '../../../assets/images/jigsawHelper/code-1.png'], ['The method begins by creating an array of integers the size of the image supplied to it and using nested for loops to iterate through both column (x) and row (y). The value of each pixelâ€™s RGB colour is then calculated for a 3x3 grid from row 0 column 0 to row 2 column 2. The size of the grid of pixels created is 3x3 so it can be passed into the edge detection logic. Both the horizontal and vertical edge detection are calculated using the appropriate operator. The Sobel operator is the computer vision chosen as it is the most effective at creating an image that shows the edges that were originally in the image. The 3x3 operation calculations using convolution to acquire a gradient that can be used to construct a greyscale image. For this application, the gradient is added to a 2d array for use in the search algorithm later in the process. This method also contains the flag setter, which will determine which of the search method will be used, colour if false and greyscale if true. The method takes the parameter of Boolean type â€˜isPieceâ€™ which means the flag section is only accessed when supplied with the piece image and not the final image. The Sobel operator produces an image with values based heavily on whether an edge exists, and therefore the pixels array will contain values above the given â€˜minRequiredToFlagâ€™ threshold of 100 if the greyscale image is the appropriate procedure for finding this particular piece. The greyscale of the final image will be compared against the piece greyscale array of the piece for the search. The field â€˜pieceEdgesFlagâ€™ is altered which tells the launch() method which method to call.', '../../../assets/images/jigsawHelper/code-2.png'], ['Once the greyscale image has been selected by the edge flag, the launch() method calls the following method to search for the location of the greyscale piece within the greyscale final image. Since both images (piece and final) are greyscale, the arrays they are contained in are 2d, so the search is relatively quick compared to the coloured search. A new 2d array is made for the comparator to find the location. This is created by copying the specified range of the 2d final image array into the new comparator array, the size of this cut is equal to the piece array size. The matching comparator array size with the piece array size allows the mean squared error logic in the method below to iterate across the final image comparing the exact piece size for each new line of pixels in the final image. Once the meanSquaredError() method has found the likely position, the Map object is populated with locations and scores.', '../../../assets/images/jigsawHelper/code-3.png'], ['The code within the meanSquaredErrorGreyScale() method is the translation of the mean squared error formula (MSE = (1/n) * Î£(actual â€“ forecast)2) to Java for use in the search. As called by searchImageGreyScale(), the comparator array minus the â€˜subImageArrayâ€™ (piece 2d array) is fed into the mean squared error formula to acquire the error value. The error is then squared and divided by (x*y axis) of the image. The return of this method is the mean squared error after these calculations are completed. The â€˜pieceLocationsAndScoresâ€™ Map now contains the mean squared error as the score, where the closer to 0 the value the more likely the piece is in that location - a better score. Due to the compression lossy that occurs with images, the mean squared error is needed as the location will never be 100% certain, otherwise the search would just be the final image array minus the comparator at each pixel location until the result is 0. Since this will not occur as explained, the mean squared error is the perfect compromise of certainty with mathematical confidence without an exact match, the score is a sufficient marker for accuracy.', '../../../assets/images/jigsawHelper/code-4.png'], ['Alternatively, if the color array is required, the getColourArray() method is called. This populates a 3d array with the pixel values of Red, Green and Blue for each pixel within the image supplied to it as a parameter.', '../../../assets/images/jigsawHelper/code-5.png'], ['The searchImageColour() method has a very similar functionality to the greyscale version, with the major difference being the 3d array for the colour array.', '../../../assets/images/jigsawHelper/code-6.png'], ['The meanSquareErrorColour() method again has very similar functionality to the greyscale version, with the colour version using a 3d array.', '../../../assets/images/jigsawHelper/code-7.png'], [ 'This button event is where the two classes link together, with the actionPerformed() method using a try/catch clause to call the launch() method from the LocationAlgorithm class. The resulting LinkedHashMap, â€˜sortedMapâ€™, populated by the launch() method uses the first 2 elements as the x and y coordinates for the top left of the box. The drawLocationRed() method is then called with the parameters using the most likely position of the piece, as the first x and y coordinates in the â€˜answersâ€™ array have the smallest mean squared error. The method also sets the fields â€˜xCoord2â€™ and â€˜yCoord2â€™ for use in the completedFullSizeButton by totalling the values of each x and y coordinate for the top  10 most likely positions (based on mean square error score) and putting the mean into an ArrayList for x and for y. The top 10 were chosen to represent the mean as some tests returned far too many answers for an accurate and representative mean, so the number is limited to 10. If the total number of locations found is less than 10, all options are considered in the mean calculations. Each of the positionOfPiece variables is the type cast array value from the correct value in the LinkedHashMap returned by LocationAlgorithm launch().', '../../../assets/images/jigsawHelper/code-9.png'], ['Once the algorithm has determined the location of the piece within the finished image, the application then draws the location as a box for the user to see the result of the computation. Since the algorithm can supply more than one method of retrieving the result through taking a mean of results based on mean squared error, there are other methods with the same functionality that draw a different colour box. ', '../../../assets/images/jigsawHelper/code-8.png'], ['An example of how the Java GUI elements are styled. The purpose of the completedFullSizeButton to also show the user other possible locations, seen by the â€˜setText("Click Here To See All Possible Locations")â€™ method invoked on the button. The button shows the user the finished image in its full size in a new window along with as blue box that uses the fields â€˜xCoord2â€™ and â€˜yCoord2â€™ to draw a blue box around the mean of all possible locations. This method also redraws the same red box as before on the new window image.', '../../../assets/images/jigsawHelper/code-10.png']],
        // screenshot1: '../../../assets/images/jigsawHelper/gui.png',
        // screenshot1Description: 'The GUI for this Java application. The application interface is split into the 3 key areas: "The Finished Puzzle", "The Indivdiual Piece" and "The Location!!!!". In the top left, a user can upload an image of the puzzle (such as from the box), see more information and view the full size image. The same functionality occurs where the user is invited to upload the puzzle piece they need help locating. The location section is where the user will receive the answer to the location of the piece within the finished image, only once the 2 uploads have been carried out.',
        // screenshot2: '../../../assets/images/jigsawHelper/screenshot-2.png',
        // screenshot2Description: 'After clicking on the "Find Piece" button, the program will draw a red box around the area most likely to contain the location of the piece. This is an example of a color search (conducted as there are no edges in the puzzle piece), which resulted in an excellent red box with the colour search because the colour in the piece was so vivid and unique to that area of the finished image.',
        // screenshot3: '../../../assets/images/jigsawHelper/screenshot-3.png',
        // screenshot3Description: 'If the user clicks on the "Click Here To See All Possible Locations" button, a separate window will open. This window will contain the red box as before (indicating the most likely area) and the mean of the top 10 (if at least 10 possibilities) most likely locations in the blue box. The green box is the exact location and has been manually entered to test accuracy. With this example, the blue box was skewed to the right by the similar orange colours surrounding the light source of the sun in the finished image, pushing the mean away from the most accurate result. This test also only used 3 locations for the blue box mean result, as the colour search output only 3 suitable locations for the piece. ',
        // screenshot4: '../../../assets/images/jigsawHelper/screenshot-4.png',
        // screenshot4Description: 'Another testing picture, The Zed image, has a bright center on the edge piece chosen which is surrounded by other sharp edges clearly influencing the greyscale pixel values as all 3 boxes feature it prominently. ',
        // screenshot5: '../../../assets/images/jigsawHelper/screenshot-5.png',
        // screenshot5Description: 'The greyscale search for this image yielded more than 10 possibilites for location, and so the top 10 would have been used for the blue box.',
        // screenshot6: '../../../assets/images/jigsawHelper/screenshot-6.png',
        // screenshot6Description: 'The accompanying image shows both the greyscale and color searches respectively. The most edge here is the sharp color change from red to black. The color search found a more accurate likely location. However, the greyscale search had a better mean result. This is likely due to the color edge being repeated 3 times across the image - as seen by the middle edge being highlighted as mean, whereas the grey scale could not determine between the left/right and right/left edge color shift. The conclusions drawn from this study were that the color array algorigthm was more accurate for determining location as it considered an extra dimension in the array. However, this caused a slower runtime - so the edge detection allowed the quicker greyscale search to be conducted where possible. The compression lossy suffered by images when uploaded to the application resulted in close but not exact matches. This uncertainty causes unreliability, so an optimisation that decreased the impact of compression lossy would be very beneficial.',
        // code1: '../../../assets/images/jigsawHelper/code-1.png',
        // code1Description: 'The method called by the completedFindButton() method in the GUI class CreateInterface to show the user where the piece fits, returning the LinkedHashMap "sortedMap" that contains all of the possible locations ranked by score (lower mean squared error is a better score) required to draw the rectangle onto the finished image. Initially, the sobelDetector() method is called to acquire the edge flag Boolean so the program knows whether to use the coloured 3d array or greyscale 2d array for the search. The threshold for the mean squared error is lower for the colour array as it is a more thorough search and therefore must have a stricter criteria to be considered a possible location. The "sortedMap" LinkedHashMap is where the possible locations for the piece are stored, ordered by their mean square error score, so the most likely piece is at the first part of the array.',
        // code2: '../../../assets/images/jigsawHelper/code-2.png',
        // code2Description: 'The method begins by creating an array of integers the size of the image supplied to it and using nested for loops to iterate through both column (x) and row (y). The value of each pixelâ€™s RGB colour is then calculated for a 3x3 grid from row 0 column 0 to row 2 column 2. The size of the grid of pixels created is 3x3 so it can be passed into the edge detection logic. Both the horizontal and vertical edge detection are calculated using the appropriate operator. The Sobel operator is the computer vision chosen as it is the most effective at creating an image that shows the edges that were originally in the image. The 3x3 operation calculations using convolution to acquire a gradient that can be used to construct a greyscale image. For this application, the gradient is added to a 2d array for use in the search algorithm later in the process. This method also contains the flag setter, which will determine which of the search method will be used, colour if false and greyscale if true. The method takes the parameter of Boolean type â€˜isPieceâ€™ which means the flag section is only accessed when supplied with the piece image and not the final image. The Sobel operator produces an image with values based heavily on whether an edge exists, and therefore the pixels array will contain values above the given â€˜minRequiredToFlagâ€™ threshold of 100 if the greyscale image is the appropriate procedure for finding this particular piece. The greyscale of the final image will be compared against the piece greyscale array of the piece for the search. The field â€˜pieceEdgesFlagâ€™ is altered which tells the launch() method which method to call.',
        // code3:  '../../../assets/images/jigsawHelper/code-3.png',
        // code3Description: 'Once the greyscale image has been selected by the edge flag, the launch() method calls the following method to search for the location of the greyscale piece within the greyscale final image. Since both images (piece and final) are greyscale, the arrays they are contained in are 2d, so the search is relatively quick compared to the coloured search. A new 2d array is made for the comparator to find the location. This is created by copying the specified range of the 2d final image array into the new comparator array, the size of this cut is equal to the piece array size. The matching comparator array size with the piece array size allows the mean squared error logic in the method below to iterate across the final image comparing the exact piece size for each new line of pixels in the final image. Once the meanSquaredError() method has found the likely position, the Map object is populated with locations and scores.',
        // code4:  '../../../assets/images/jigsawHelper/code-4.png',
        // code4Description: 'The code within the meanSquaredErrorGreyScale() method is the translation of the mean squared error formula (MSE = (1/n) * Î£(actual â€“ forecast)2) to Java for use in the search. As called by searchImageGreyScale(), the comparator array minus the â€˜subImageArrayâ€™ (piece 2d array) is fed into the mean squared error formula to acquire the error value. The error is then squared and divided by (x*y axis) of the image. The return of this method is the mean squared error after these calculations are completed. The â€˜pieceLocationsAndScoresâ€™ Map now contains the mean squared error as the score, where the closer to 0 the value the more likely the piece is in that location - a better score. Due to the compression lossy that occurs with images, the mean squared error is needed as the location will never be 100% certain, otherwise the search would just be the final image array minus the comparator at each pixel location until the result is 0. Since this will not occur as explained, the mean squared error is the perfect compromise of certainty with mathematical confidence without an exact match, the score is a sufficient marker for accuracy.',
        // code5:  '../../../assets/images/jigsawHelper/code-5.png',
        // code5Description: 'Alternatively, if the color array is required, the getColourArray() method is called. This populates a 3d array with the pixel values of Red, Green and Blue for each pixel within the image supplied to it as a parameter.',
        // code6:  '../../../assets/images/jigsawHelper/code-6.png',
        // code6Description: 'The searchImageColour() method has a very similar functionality to the greyscale version, with the major difference being the 3d array for the colour array.',
        // code7:  '../../../assets/images/jigsawHelper/code-7.png',
        // code7Description: 'The meanSquareErrorColour() method again has very similar functionality to the greyscale version, with the colour version using a 3d array.',
        // code8:  '../../../assets/images/jigsawHelper/code-9.png',
        // code8Description: 'This button event is where the two classes link together, with the actionPerformed() method using a try/catch clause to call the launch() method from the LocationAlgorithm class. The resulting LinkedHashMap, â€˜sortedMapâ€™, populated by the launch() method uses the first 2 elements as the x and y coordinates for the top left of the box. The drawLocationRed() method is then called with the parameters using the most likely position of the piece, as the first x and y coordinates in the â€˜answersâ€™ array have the smallest mean squared error. The method also sets the fields â€˜xCoord2â€™ and â€˜yCoord2â€™ for use in the completedFullSizeButton by totalling the values of each x and y coordinate for the top  10 most likely positions (based on mean square error score) and putting the mean into an ArrayList for x and for y. The top 10 were chosen to represent the mean as some tests returned far too many answers for an accurate and representative mean, so the number is limited to 10. If the total number of locations found is less than 10, all options are considered in the mean calculations. Each of the positionOfPiece variables is the type cast array value from the correct value in the LinkedHashMap returned by LocationAlgorithm launch().',
        // code9:  '../../../assets/images/jigsawHelper/code-8.png',
        // code9Description: 'Once the algorithm has determined the location of the piece within the finished image, the application then draws the location as a box for the user to see the result of the computation. Since the algorithm can supply more than one method of retrieving the result through taking a mean of results based on mean squared error, there are other methods with the same functionality that draw a different colour box. ',
        // code10: '../../../assets/images/jigsawHelper/code-10.png',
        // code10Description: 'An example of how the Java GUI elements are styled. The purpose of the completedFullSizeButton to also show the user other possible locations, seen by the â€˜setText("Click Here To See All Possible Locations")â€™ method invoked on the button. The button shows the user the finished image in its full size in a new window along with as blue box that uses the fields â€˜xCoord2â€™ and â€˜yCoord2â€™ to draw a blue box around the mean of all possible locations. This method also redraws the same red box as before on the new window image.',
    },
    {
        id: 2,
        title: 'GitHub Searcher',
        url: 'https://dan-react-github-search.netlify.app/',
        GitHub: 'https://github.com/WalkingZ3d/github-tracker',
        summary: 'A React front-end exclusive application to search for a given users repositories. This application makes uses of React routing, state, reducers and useEffect() Hooks to achieve its result.',
        description: 'A React front-end exclusive application to search for a given users repositories. This application makes uses of React routing, state, reducers and useEffect() Hooks to achieve its result.',
        picture: '../../../assets/images/repoSearcher/main-screenshot.png',
        stamp: '../../../assets/images/stamps/personal-pink-clear.png',
        framework: '../../../assets/images/frameworkIcons/react-logo.png',
        screenshot: [['The homepage for the GitHub repository searcher. To use, simply enter a valid GitHub username and press the "Search" button. This will fire a GET request using axios to the GitHub API to retrieve the publicly listed repositories for that user.', '../../../assets/images/repoSearcher/main-screenshot.png'], ['Once the GitHub API has been called, the page is populated with all of the titles of thats user\'s repositories. The user may choose how many results they want per page and use the "Next" and "Prev" buttons to navigate between pages of repositories. This page also includes a reset search button to allow a fresh search to be undertaken. When a user clicks on one of the titles, they are redirected to a new page with the searched username and title of the clicked repository in the URL parameters.', '../../../assets/images/repoSearcher/screenshot-2.png'], ['The page for information on each repository uses the URL parameters of username and repository title to make an axios GET request for data about said repository. This information is then slotted into a custom card component and displayed to the user.', '../../../assets/images/repoSearcher/screenshot-3.png'], ['This page takes advantage of React Routing to provide the user with a custom 404 page if they navigate to a non-existant route.', '../../../assets/images/repoSearcher/screenshot-4.png']],
        code: [['This useEffect() React Hook is located in the source code for the "Search" page and fires whenever a new username is searched. The asynchronous function, seen between lines 20 and 29, makes a call to the GitHub API to update both the reposCount (number of repositories for that username) and ownerName (username) React States - and is called recursively on line 31. This method of nested async function is necessary as the useEffect itself cannot be asynchronous. ', '../../../assets/images/repoSearcher/code-1.png'], [ 'This useEffect() is also located in the source code for the "Search" page and fires whenever the number of pages are changed, username is changed or a new page is navigated to. The async function, seen between lines 44 and 62, sets the number of pages required (lines 46 and 47) and calls the API to get as many repositories as each page will show. This function is also called recursively within the useEffect.', '../../../assets/images/repoSearcher/code-2.png'], [ 'The function renderRepos(), lines 86-88, maps the gathered repository data to <li> elements for display on the page. Each one will navigate to the username/repositoryName upon click as the map allows for each link to use the title as a URL Parameter. RenderRepos() is called in the HTML return of this page. The 2 functions underneath (lines 90 - 105) handle the pagination controls of the Search page. Since the number of pages changes based on the user selection from a dropdown, these 2 functions use States to determine whether page navigation is possible or not.', '../../../assets/images/repoSearcher/code-3.png'], ['When the user clicks on a repository to see more information on the Search page, the username and repository name are added as URL parameters. On the Results page, the useParams() Hook (seen on line 9) is used to grab those pieces of data for later use. The useEffect(), shown between lines 14 and 25, is fired whenever the name changes - which is upon navigation to the page. The async function within then makes a call to the GitHub API to gather data about that paticular repository and add it to the empty object of RepoData seen on line 10. A card is then generated for the data between lines 29 and 31.', '../../../assets/images/repoSearcher/code-4.png'], ['The App uses React Routing to allow the user to believe they are moving between pages. Line 9 adds the basic layout of Header and Footer to all pages. Lines 10 - 15 are the nested routes required to allow the URL parameters to move to username/repositoryTitle and show the information to the user. Line 16 navigates the user to an about page where they can learn how to use the app. The final route on line 17 acts as a catch all to display a 404 page if the user tries to move to a URL that does not exist within the application.', '../../../assets/images/repoSearcher/code-5.png']],
        // screenshot1: '../../../assets/images/repoSearcher/main-screenshot.png',
        // screenshot1Description: 'The homepage for the GitHub repository searcher. To use, simply enter a valid GitHub username and press the "Search" button. This will fire a GET request using axios to the GitHub API to retrieve the publicly listed repositories for that user.',
        // screenshot2: '../../../assets/images/repoSearcher/screenshot-2.png',
        // screenshot2Description: 'Once the GitHub API has been called, the page is populated with all of the titles of thats user\'s repositories. The user may choose how many results they want per page and use the "Next" and "Prev" buttons to navigate between pages of repositories. This page also includes a reset search button to allow a fresh search to be undertaken. When a user clicks on one of the titles, they are redirected to a new page with the searched username and title of the clicked repository in the URL parameters.',
        // screenshot3: '../../../assets/images/repoSearcher/screenshot-3.png',
        // screenshot3Description: 'The page for information on each repository uses the URL parameters of username and repository title to make an axios GET request for data about said repository. This information is then slotted into a custom card component and displayed to the user.',
        // screenshot4: '../../../assets/images/repoSearcher/screenshot-4.png',
        // screenshot4Description: 'This page takes advantage of React Routing to provide the user with a custom 404 page if they navigate to a non-existant route.',
        // code1: '../../../assets/images/repoSearcher/code-1.png',
        // code1Description: 'This useEffect() React Hook is located in the source code for the "Search" page and fires whenever a new username is searched. The asynchronous function, seen between lines 20 and 29, makes a call to the GitHub API to update both the reposCount (number of repositories for that username) and ownerName (username) React States - and is called recursively on line 31. This method of nested async function is necessary as the useEffect itself cannot be asynchronous. ',
        // code2: '../../../assets/images/repoSearcher/code-2.png',
        // code2Description: 'This useEffect() is also located in the source code for the "Search" page and fires whenever the number of pages are changed, username is changed or a new page is navigated to. The async function, seen between lines 44 and 62, sets the number of pages required (lines 46 and 47) and calls the API to get as many repositories as each page will show. This function is also called recursively within the useEffect.',
        // code3: '../../../assets/images/repoSearcher/code-3.png',
        // code3Description: 'The function renderRepos(), lines 86-88, maps the gathered repository data to <li> elements for display on the page. Each one will navigate to the username/repositoryName upon click as the map allows for each link to use the title as a URL Parameter. RenderRepos() is called in the HTML return of this page. The 2 functions underneath (lines 90 - 105) handle the pagination controls of the Search page. Since the number of pages changes based on the user selection from a dropdown, these 2 functions use States to determine whether page navigation is possible or not. ',
        // code4: '../../../assets/images/repoSearcher/code-4.png',
        // code4Description: 'When the user clicks on a repository to see more information on the Search page, the username and repository name are added as URL parameters. On the Results page, the useParams() Hook (seen on line 9) is used to grab those pieces of data for later use. The useEffect(), shown between lines 14 and 25, is fired whenever the name changes - which is upon navigation to the page. The async function within then makes a call to the GitHub API to gather data about that paticular repository and add it to the empty object of RepoData seen on line 10. A card is then generated for the data between lines 29 and 31.',
        // code5: '../../../assets/images/repoSearcher/code-5.png',
        // code5Description: 'The App uses React Routing to allow the user to believe they are moving between pages. Line 9 adds the basic layout of Header and Footer to all pages. Lines 10 - 15 are the nested routes required to allow the URL parameters to move to username/repositoryTitle and show the information to the user. Line 16 navigates the user to an about page where they can learn how to use the app. The final route on line 17 acts as a catch all to display a 404 page if the user tries to move to a URL that does not exist within the application.',
    },
    // {
    //     id: 3,
    //     title: 'The Motive',
    //     link: 'calorie-tracker',
    //     url: 'http://localhost:3000/',
    //     GitHub: 'https://github.com/WalkingZ3d/CalorieTracker2',
    //     summary: 'A fullstack collaborative application for finding nearby venues by geolocation for food and drink. This app uses python for the backend, with the flask framework connected to a SQL Alchamey database during development and Heroku postgress for deployment. The frontend served by the backend is a React application. My role within this project was backend, but then helping with the React frontend.',
    //     description: 'A fullstack collaborative application for finding nearby venues by geolocation for food and drink. This app uses python for the backend, with the flask framework connected to a SQL Alchamey database during development and Heroku postgress for deployment. The frontend served by the backend is a React application. My role within this project was backend, but then helping with the React frontend.',
    //     picture: '../../../assets/images/fnc.png',
    //     stamp: '../../../assets/images/stamps/collaborative-pink-clear.png',
    //     framework: '../../../assets/images/frameworkIcons/flask-logo.png',
    //     screenshot1: '../../../assets/images/calorieTracker/calorieTracker.png',
    //     screenshot1Description: 'Lorem ipsum, dolor sit amet consectetur adipisicing elit. Recusandae enim cum similique voluptas nulla? Repellat autem, incidunt magni culpa non illo, soluta quidem fugit voluptas doloremque necessitatibus at optio. Ab.',
    //     screenshot2: '../../../assets/images/calorieTracker/calorieTracker.png',
    //     screenshot2Description: 'Lorem ipsum, dolor sit amet consectetur adipisicing elit. Recusandae enim cum similique voluptas nulla? Repellat autem, incidunt magni culpa non illo, soluta quidem fugit voluptas doloremque necessitatibus at optio. Ab.',
    //     screenshot3: '../../../assets/images/calorieTracker/calorieTracker.png',
    //     screenshot3Description: 'Lorem ipsum, dolor sit amet consectetur adipisicing elit. Recusandae enim cum similique voluptas nulla? Repellat autem, incidunt magni culpa non illo, soluta quidem fugit voluptas doloremque necessitatibus at optio. Ab.',
    //     code1: '../../../assets/images/fnc.png',
    //     code1Description: 'Lorem ipsum, dolor sit amet consectetur adipisicing elit. Recusandae enim cum similique voluptas nulla? Repellat autem, incidunt magni culpa non illo, soluta quidem fugit voluptas doloremque necessitatibus at optio. Ab.',
    //     code2: '../../../assets/images/fnc.png',
    //     code2Description: 'Lorem ipsum, dolor sit amet consectetur adipisicing elit. Recusandae enim cum similique voluptas nulla? Repellat autem, incidunt magni culpa non illo, soluta quidem fugit voluptas doloremque necessitatibus at optio. Ab.',
    //     code3: '../../../assets/images/fnc.png',
    //     code3Description: 'Lorem ipsum, dolor sit amet consectetur adipisicing elit. Recusandae enim cum similique voluptas nulla? Repellat autem, incidunt magni culpa non illo, soluta quidem fugit voluptas doloremque necessitatibus at optio. Ab.',
    // },
]





